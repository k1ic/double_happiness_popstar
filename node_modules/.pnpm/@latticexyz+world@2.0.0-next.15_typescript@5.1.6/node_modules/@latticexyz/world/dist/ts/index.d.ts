import { W as WorldConfig, S as SystemConfig } from '../types-3e6fc97f.js';
export { E as ExpandSystemConfig, e as ExpandSystemsConfig, M as ModuleConfig, a as SYSTEM_DEFAULTS, c as SystemUserConfig, d as SystemsUserConfig, b as WORLD_DEFAULTS, f as WorldUserConfig, g as zPluginWorldConfig, z as zWorldConfig } from '../types-3e6fc97f.js';
import { StoreConfig } from '@latticexyz/store';
import { Abi, ContractFunctionConfig, Hex, GetFunctionArgs, Address } from 'viem';
import 'zod';
import '@latticexyz/config';
import '@latticexyz/common/type-utils';

type ResolvedSystemConfig = ReturnType<typeof resolveSystemConfig>;
type ResolvedWorldConfig = ReturnType<typeof resolveWorldConfig>;
/**
 * Resolves the world config by combining the default and overridden system configs,
 * filtering out excluded systems, validate system names refer to existing contracts, and
 * splitting the access list into addresses and system names.
 */
declare function resolveWorldConfig(config: StoreConfig & WorldConfig, existingContracts?: string[]): {
    systems: Record<string, {
        name: string;
        registerFunctionSelectors: boolean;
        openAccess: boolean;
        accessListAddresses: string[];
        accessListSystems: string[];
    }>;
};
/**
 * Resolves the system config by combining the default and overridden system configs,
 * @param systemName name of the system
 * @param config optional SystemConfig object, if none is provided the default config is used
 * @param existingContracts optional list of existing contract names, used to validate system names in the access list. If not provided, no validation is performed.
 * @returns ResolvedSystemConfig object
 * Default value for name is `systemName`
 * Default value for registerFunctionSelectors is true
 * Default value for openAccess is true
 * Default value for accessListAddresses is []
 * Default value for accessListSystems is []
 */
declare function resolveSystemConfig(systemName: string, config?: SystemConfig, existingContracts?: string[]): {
    name: string;
    registerFunctionSelectors: boolean;
    openAccess: boolean;
    accessListAddresses: string[];
    accessListSystems: string[];
};

declare const abi: [
  {
    "type": "function",
    "name": "call",
    "inputs": [
      {
        "name": "systemId",
        "type": "bytes32",
        "internalType": "ResourceId"
      },
      {
        "name": "callData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "callFrom",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "systemId",
        "type": "bytes32",
        "internalType": "ResourceId"
      },
      {
        "name": "callData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "payable"
  }
];

type SystemCall<abi extends Abi, functionName extends string = string> = Pick<ContractFunctionConfig<abi, functionName>, "abi" | "functionName" | "args"> & {
    readonly systemId: Hex;
};
/** Encode a system call to be passed as arguments into `World.call` */
declare function encodeSystemCall<abi extends Abi, functionName extends string = string>({ abi, systemId, functionName, args, }: SystemCall<abi, functionName>): GetFunctionArgs<typeof abi, "call">["args"];

type SystemCallFrom<abi extends Abi, functionName extends string = string> = SystemCall<abi, functionName> & {
    readonly from: Address;
};
/** Encode a system call to be passed as arguments into `World.callFrom` */
declare function encodeSystemCallFrom<abi extends Abi, functionName extends string = string>({ abi, from, systemId, functionName, args, }: SystemCallFrom<abi, functionName>): GetFunctionArgs<typeof abi, "callFrom">["args"];

/** Encode system calls to be passed as arguments into `World.batchCall` */
declare function encodeSystemCalls<abi extends Abi, functionName extends string = string>(abi: abi, systemCalls: readonly Omit<SystemCall<abi, functionName>, "abi">[]): GetFunctionArgs<typeof abi, "call">["args"][];

/** Encode system calls to be passed as arguments into `World.batchCallFrom` */
declare function encodeSystemCallsFrom<abi extends Abi, functionName extends string = string>(abi: abi, from: Address, systemCalls: readonly Omit<SystemCallFrom<abi, functionName>, "abi" | "from">[]): GetFunctionArgs<typeof abi, "callFrom">["args"][];

declare const worldDeployedEvent = "event WorldDeployed(address indexed newContract)";
declare const helloWorldEvent = "event HelloWorld(bytes32 indexed worldVersion)";

export { ResolvedSystemConfig, ResolvedWorldConfig, SystemCall, SystemCallFrom, SystemConfig, WorldConfig, encodeSystemCall, encodeSystemCallFrom, encodeSystemCalls, encodeSystemCallsFrom, helloWorldEvent, resolveSystemConfig, resolveWorldConfig, worldDeployedEvent };
