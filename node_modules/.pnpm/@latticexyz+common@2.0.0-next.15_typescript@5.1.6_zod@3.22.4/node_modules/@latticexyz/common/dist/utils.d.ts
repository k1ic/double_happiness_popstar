declare function assertExhaustive(value: never, message?: string): never;

declare function bigIntMax(...args: bigint[]): bigint;

declare function bigIntMin(...args: bigint[]): bigint;

declare function bigIntSort(a: bigint, b: bigint): -1 | 0 | 1;

declare function chunk<T>(arr: readonly T[], n: number): Generator<readonly T[], void>;

declare function curry<F extends (...params: [...P, ...any[]]) => any, P extends any[]>(func: F, ...partialParams: P): CurryParams<F, P>;
type CurryParams<F extends (...params: [...PartialParams, ...any[]]) => any, PartialParams extends any[]> = F extends (...params: [...PartialParams, ...infer RemainingParams]) => infer Result ? (...params: RemainingParams) => Result : never;

declare function groupBy<value, key>(values: readonly value[], getKey: (value: value) => key): Map<key, readonly value[]>;

declare function identity<T>(value: T): T;

declare function includes<item>(items: item[], value: any): value is item;

declare function isDefined<T>(argument: T | undefined): argument is T;

declare function isNotNull<T>(argument: T | null): argument is T;

declare function iteratorToArray<T>(iterator: AsyncIterable<T>): Promise<T[]>;

/**
 * Map each key of a source object via a given valueMap function
 */
declare function mapObject<Source extends Record<string | number | symbol, unknown>, Target extends {
    [key in keyof Source]: unknown;
}>(source: Source, valueMap: (value: Source[typeof key], key: keyof Source) => Target[typeof key]): Target;

declare function unique<value>(values: readonly value[]): readonly value[];

declare function uniqueBy<value, key>(values: readonly value[], getKey: (value: value) => key): readonly value[];

declare function wait(ms: number): Promise<void>;

declare function waitForIdle(): Promise<void>;

export { assertExhaustive, bigIntMax, bigIntMin, bigIntSort, chunk, curry, groupBy, identity, includes, isDefined, isNotNull, iteratorToArray, mapObject, unique, uniqueBy, wait, waitForIdle };
