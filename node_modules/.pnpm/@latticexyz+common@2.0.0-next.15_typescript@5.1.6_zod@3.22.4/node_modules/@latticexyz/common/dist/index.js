import{a as u}from"./chunk-TCWGPC6G.js";import $ from"debug";var P=$("mud:benchmark");P.log=console.info.bind(console);function le(e){let r=P.extend(e),n=performance.now();return o=>{let t=(performance.now()-n)/1e3;r("%s: +%ds",o,t),n=performance.now()}}import{privateKeyToAccount as S}from"viem/accounts";function ge(e){return{...S(e)}}import{BaseError as G,NonceTooHighError as D,NonceTooLowError as Q}from"viem";import{getAddress as B}from"viem";import{getChainId as F}from"viem/actions";async function T({client:e,address:r,blockTag:n}){return`mud:createNonceManager:${e.chain?.id??await F(e)}:${B(r)}:${n}`}import{getTransactionCount as _}from"viem/actions";import j from"p-queue";var R=u.extend("createNonceManager");function k({client:e,address:r,blockTag:n="pending",broadcastChannelName:o}){let t={current:-1},a=null;typeof BroadcastChannel<"u"&&(o?Promise.resolve(o):T({client:e,address:r,blockTag:n})).then(p=>{a=new BroadcastChannel(p),a.addEventListener("message",m=>{let d=JSON.parse(m.data);R("got nonce from broadcast channel",d),t.current=d})});function s(){return t.current>=0}function c(){if(!s())throw new Error("call resetNonce before using nextNonce");let i=t.current++;return a?.postMessage(JSON.stringify(t.current)),i}async function g(){let i=await _(e,{address:r,blockTag:n});t.current=i,a?.postMessage(JSON.stringify(t.current)),R("reset nonce to",t.current)}function C(i){return i instanceof G&&i.walk(p=>p instanceof Q||p instanceof D)!=null}let h=new j({concurrency:1});return{hasNonce:s,nextNonce:c,resetNonce:g,shouldResetNonce:C,mempoolQueue:h}}import{getContract as U}from"viem";import{simulateContract as z,writeContract as J}from"viem/actions";import K from"p-retry";var O=new Map;async function l({client:e,address:r,blockTag:n="pending"}){let o=await T({client:e,address:r,blockTag:n}),t=O.get(o);if(t)return t;let a=k({client:e,address:r,blockTag:n});return O.set(o,a),a}import{parseAccount as L}from"viem/accounts";var f=u.extend("writeContract");async function H(e,r){let n=r.account??e.account;if(!n)throw new Error("No account provided");let o=L(n),t=await l({client:e,address:o.address,blockTag:"pending"});async function a(){return r.gas?(f("gas provided, skipping simulate",r.functionName,r.address),r):(f("simulating",r.functionName,"at",r.address),(await z(e,{...r,blockTag:"pending",account:o})).request)}let s=await a();return t.mempoolQueue.add(()=>K(async()=>{t.hasNonce()||await t.resetNonce();let c=t.nextNonce();return f("calling",s.functionName,"with nonce",c,"at",s.address),await J(e,{nonce:c,...s})},{retries:3,onFailedAttempt:async c=>{if(t.shouldResetNonce(c)){f("got nonce error, retrying",c.message),await t.resetNonce();return}throw c}}),{throwOnTimeout:!0})}function V(e){let r=e.length&&Array.isArray(e[0]),n=r?e[0]:[],o=(r?e[1]:e[0])??{};return{args:n,options:o}}function v({abi:e,address:r,publicClient:n,walletClient:o,onWrite:t}){let a=U({abi:e,address:r,publicClient:n,walletClient:o});if(a.write){let s=0;a.write=new Proxy({},{get(c,g){return(...C)=>{let{args:h,options:i}=V(C),p={abi:e,address:r,functionName:g,args:h,...i,onWrite:t},m=H(o,p),d=`${o.chain.id}:${o.account.address}:${s++}`;return t?.({id:d,request:p,result:m}),m}}})}return a}import{generatePrivateKey as X,privateKeyToAccount as W}from"viem/accounts";import{isHex as Y}from"viem";function Z(e,r){if(!Y(e))throw console.error("Private key found in cache is not valid hex",{privateKey:e,cacheKey:r}),new Error(`Private key found in cache (${r}) is not valid hex`);W(e)}function ir(e="mud:burnerWallet"){let r=localStorage.getItem(e);if(r!=null)return Z(r,e),r;let n=X();return console.log("New burner wallet created:",W(n)),localStorage.setItem(e,n),n}import{hexToString as A,sliceHex as w}from"viem";var M=["table","offchainTable","namespace","module","system"];import{stringToHex as b,concatHex as q}from"viem";var y={table:"tb",offchainTable:"ot",namespace:"ns",module:"md",system:"sy"};function E(e){let r=y[e.type];return q([b(r,{size:2}),b(e.namespace.slice(0,14),{size:14}),b(e.name.slice(0,16),{size:16})])}var ee=Object.fromEntries(Object.entries(y).map(([e,r])=>[r,e]));function re(e){let r=ee[e];if(M.includes(r))return r}function I(e){let r=A(w(e,0,2)).replace(/\0+$/,""),n=re(r),o=A(w(e,2,16)).replace(/\0+$/,""),t=A(w(e,16,32)).replace(/\0+$/,"");if(!n)throw new Error(`Unknown type (${r}) for resource (${r}:${o}:${t})`);return{resourceId:e,type:n,namespace:o,name:t}}function N(e,r,n){return`0x${e.replace(/^0x/,"").slice(r*2,n!=null?n*2:void 0).padEnd(((n??r)-r)*2,"0")}`}function yr(e){return"ok"in e}function te(e){return"error"in e}function Ar(e){if(te(e))throw e.error;return e.ok}import{call as ne,sendTransaction as oe}from"viem/actions";import ae from"p-retry";import{parseAccount as ce}from"viem/accounts";var x=u.extend("sendTransaction");async function Hr(e,r){let n=r.account??e.account;if(!n)throw new Error("No account provided");let o=ce(n),t=await l({client:e,address:o.address,blockTag:"pending"});async function a(){return r.gas?(x("gas provided, skipping simulate",r.to),r):(x("simulating tx to",r.to),await ne(e,{...r,blockTag:"pending",account:o}),r)}let s=await a();return await t.mempoolQueue.add(()=>ae(async()=>{t.hasNonce()||await t.resetNonce();let c=t.nextNonce();return x("sending tx with nonce",c,"to",s.to),await oe(e,{nonce:c,...s})},{retries:3,onFailedAttempt:async c=>{if(t.shouldResetNonce(c)){x("got nonce error, retrying",c.message),await t.resetNonce();return}throw c}}),{throwOnTimeout:!0})}import{concatHex as se}from"viem";function Ir(e,r,n=0,o="0x"){return se([N(e,0,r),o,N(e,r+n)])}import{keccak256 as ie}from"viem";var ue=u.extend("transportObserver");function Dr(e){return r=>{let n=e(r);return{...n,request:async t=>{if(t.method==="eth_sendRawTransaction"&&t.params instanceof Array){let a=t.params.map(s=>ie(s));ue("saw txs",a)}return n.request(t)}}}}var pe=v;var me=E;var de=I;export{le as createBenchmark,ge as createBurnerAccount,pe as createContract,k as createNonceManager,ir as getBurnerPrivateKey,v as getContract,l as getNonceManager,T as getNonceManagerId,I as hexToResource,de as hexToResourceId,te as isError,yr as isOk,N as readHex,me as resourceIdToHex,E as resourceToHex,y as resourceTypeIds,M as resourceTypes,Hr as sendTransaction,Ir as spliceHex,Dr as transportObserver,Ar as unwrap,H as writeContract};
//# sourceMappingURL=index.js.map