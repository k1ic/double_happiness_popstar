import { SchemaType } from '@latticexyz/schema-type/deprecated';
import { SchemaAbiType } from '@latticexyz/schema-type';

declare module "prettier-plugin-solidity" {}

interface AbsoluteImportDatum {
    symbol: string;
    path: string;
}
interface RelativeImportDatum {
    symbol: string;
    fromPath: string;
    usedInPath: string;
}
type ImportDatum = AbsoluteImportDatum | RelativeImportDatum;
interface StaticResourceData {
    /** Name of the table id constant to render. */
    tableIdName: string;
    namespace: string;
    name: string;
    offchainOnly: boolean;
}
interface RenderType {
    typeId: string;
    typeWithLocation: string;
    /** The name of the enum element in SchemaType to use for schema registration (e.g. "UINT256_ARRAY") */
    enumName: string;
    staticByteLength: number;
    isDynamic: boolean;
    /** Empty for internal types. Custom `wrap` method for user defined types. */
    typeWrap: string;
    /** Empty for internal types. Custom `unwrap` method for user defined types. */
    typeUnwrap: string;
    /** Data to generate the custom wrapper and unwrapper if necessary. */
    typeWrappingData?: RenderFieldTypeWrappingData;
    /** Same as typeId for internal types. The underlying `typeId` for user defined types. */
    internalTypeId: string;
}
interface RenderKeyTuple extends RenderType {
    name: string;
    isDynamic: false;
}
interface RenderField extends RenderType {
    arrayElement: RenderType | undefined;
    name: string;
}
interface RenderStaticField extends RenderField {
    isDynamic: false;
}
interface RenderDynamicField extends RenderField {
    isDynamic: true;
}
type RenderFieldTypeWrappingData = {
    kind: "staticArray";
    elementType: string;
    staticLength: number;
};
interface RenderEnum {
    name: string;
    memberNames: string[];
}

declare const renderedSolidityHeader = "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */";
/**
 * Renders a list of lines
 */
declare function renderList<T>(list: T[], renderItem: (item: T, index: number) => string): string;
/**
 * Renders a comma-separated list of arguments for solidity functions, ignoring empty and undefined ones
 */
declare function renderArguments(args: (string | undefined)[]): string;
declare function renderCommonData({ staticResourceData, keyTuple, }: {
    staticResourceData?: StaticResourceData;
    keyTuple: RenderKeyTuple[];
}): {
    _tableId: string;
    _typedTableId: string;
    _keyArgs: string;
    _typedKeyArgs: string;
    _keyTupleDefinition: string;
};
/** For 2 paths which are relative to a common root, create a relative import path from one to another */
declare function solidityRelativeImportPath(fromPath: string, usedInPath: string): string;
/**
 * Aggregates, deduplicates and renders imports for symbols per path.
 * Identical symbols from different paths are NOT handled, they should be checked before rendering.
 */
declare function renderImports(imports: ImportDatum[]): string;
/**
 * Aggregates, deduplicates and renders imports for symbols per path.
 * Identical symbols from different paths are NOT handled, they should be checked before rendering.
 */
declare function renderRelativeImports(imports: RelativeImportDatum[]): string;
/**
 * Aggregates, deduplicates and renders imports for symbols per path.
 * Identical symbols from different paths are NOT handled, they should be checked before rendering.
 */
declare function renderAbsoluteImports(imports: AbsoluteImportDatum[]): string;
declare function renderWithStore(storeArgument: boolean, callback: (_typedStore: string | undefined, _store: string, _commentSuffix: string, _untypedStore: string | undefined, _methodPrefix: string, _internal?: boolean) => string): string;
declare function renderWithFieldSuffix(withSuffixlessFieldMethods: boolean, fieldName: string, callback: (_methodNameSuffix: string) => string): string;
declare function renderTableId({ namespace, name, offchainOnly, tableIdName }: StaticResourceData): {
    hardcodedTableId: string;
    tableIdDefinition: string;
};
declare function renderValueTypeToBytes32(name: string, { typeUnwrap, internalTypeId }: RenderType): string;
declare function isLeftAligned(field: Pick<RenderType, "internalTypeId">): boolean;
declare function getLeftPaddingBits(field: Pick<RenderType, "internalTypeId" | "staticByteLength">): number;

declare function renderEnums(enums: RenderEnum[]): string;

declare function renderTypeHelpers(options: {
    fields: RenderField[];
    keyTuple: RenderKeyTuple[];
}): string;

declare const schemaTypesToRecsTypeStrings: Record<SchemaType, string>;

interface ContractInterfaceFunction {
    name: string;
    parameters: string[];
    stateMutability: string;
    returnParameters: string[];
}
interface ContractInterfaceError {
    name: string;
    parameters: string[];
}
interface SymbolImport {
    symbol: string;
    path: string;
}
/**
 * Parse the contract data to get the functions necessary to generate an interface,
 * and symbols to import from the original contract.
 * @param data contents of a file with the solidity contract
 * @param contractName name of the contract
 * @returns interface data
 */
declare function contractToInterface(data: string, contractName: string): {
    functions: ContractInterfaceFunction[];
    errors: ContractInterfaceError[];
    symbolImports: SymbolImport[];
};

interface SolidityUserDefinedType {
    typeId: string;
    internalTypeId: string;
    importSymbol: string;
    fromPath: string;
    isRelativePath: boolean;
}
/**
 * Parse the solidity data to extract user-defined type information.
 * @param data contents of a solidity file with the user types declarations
 * @param userTypeNames names of the user types to extract
 */
declare function extractUserTypes(data: string, userTypeNames: string[], fromPath: string): Record<string, SolidityUserDefinedType>;

declare function formatSolidity(content: string, prettierConfigPath?: string): Promise<string>;
declare function formatTypescript(content: string): Promise<string>;

declare function formatAndWriteSolidity(output: string, fullOutputPath: string, logPrefix: string): Promise<void>;
declare function formatAndWriteTypescript(output: string, fullOutputPath: string, logPrefix: string): Promise<void>;

type UserType = {
    filePath: string;
    internalType: SchemaAbiType;
};
declare function loadAndExtractUserTypes(userTypes: Record<string, UserType>, outputBaseDirectory: string, remappings: [string, string][]): Record<string, SolidityUserDefinedType>;

/**
 * Explicitly normalize a given path to a posix path (using `/` as separator).
 * This should be used for generating Solidity files that will be consumed by solc,
 * because solc expects `/` as path separator, but path.join produces `\` if the user is on windows.
 */
declare function posixPath(path: string): string;

export { AbsoluteImportDatum, ContractInterfaceError, ContractInterfaceFunction, ImportDatum, RelativeImportDatum, RenderDynamicField, RenderEnum, RenderField, RenderFieldTypeWrappingData, RenderKeyTuple, RenderStaticField, RenderType, SolidityUserDefinedType, StaticResourceData, UserType, contractToInterface, extractUserTypes, formatAndWriteSolidity, formatAndWriteTypescript, formatSolidity, formatTypescript, getLeftPaddingBits, isLeftAligned, loadAndExtractUserTypes, posixPath, renderAbsoluteImports, renderArguments, renderCommonData, renderEnums, renderImports, renderList, renderRelativeImports, renderTableId, renderTypeHelpers, renderValueTypeToBytes32, renderWithFieldSuffix, renderWithStore, renderedSolidityHeader, schemaTypesToRecsTypeStrings, solidityRelativeImportPath };
